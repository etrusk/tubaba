<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battle Viewer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      color: #fff;
      min-height: 100vh;
      padding: 20px;
    }

    .battle-viewer {
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 100vw;
      width: 100%;
    }

    h1 {
      text-align: center;
      font-size: 2.5rem;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      margin-bottom: 10px;
    }

    /* Three-column layout */
    .battle-arena {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 20px;
      min-height: 500px;
    }

    /* Left column: stacked enemies and players */
    .battle-column-left {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* Middle column: Action Forecast */
    .battle-column-middle {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* Right column: Rule Evaluations (Debug Inspector) */
    .battle-column-right {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .panel {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .panel h2 {
      font-size: 1.5rem;
      margin-bottom: 15px;
      text-align: center;
      color: #ffd700;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    /* Character Cards */
    .character-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .character-card {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      padding: 15px;
      border: 2px solid transparent;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .character-card:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .character-card.player {
      border-color: #4caf50;
    }

    .character-card.enemy {
      border-color: #f44336;
    }

    .character-card.selected {
      border-color: #ffd700;
      background: rgba(255, 215, 0, 0.2);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
    }

    .character-name {
      font-size: 1.2rem;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .hp-bar-container {
      position: relative;
      background: rgba(0, 0, 0, 0.3);
      height: 24px;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .hp-bar {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, #4caf50, #8bc34a);
      transition: width 0.5s ease;
    }

    .character-card.enemy .hp-bar {
      background: linear-gradient(90deg, #f44336, #ff6b6b);
    }

    .hp-text {
      position: absolute;
      width: 100%;
      text-align: center;
      line-height: 24px;
      font-weight: bold;
      font-size: 0.9rem;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }

    .ko-indicator {
      background: #d32f2f;
      color: #fff;
      text-align: center;
      padding: 4px;
      border-radius: 4px;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .status-effects {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 8px;
      min-height: 24px;
    }

    .status {
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: bold;
    }

    .status.shielded { background: #2196f3; }
    .status.poisoned { background: #9c27b0; }
    .status.stunned { background: #ff9800; }
    .status.defending { background: #607d8b; }
    .status.enraged { background: #e91e63; }
    .status.taunting { background: #ff5722; }

    .action-display {
      font-size: 0.9rem;
      color: #ffd700;
    }

    .action-name {
      font-weight: bold;
      margin-right: 5px;
    }

    .ticks-remaining {
      background: rgba(255, 215, 0, 0.2);
      padding: 2px 6px;
      border-radius: 3px;
    }

    /* Controls Panel */
    .controls-panel {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }

    .tick-display {
      font-size: 2rem;
      font-weight: bold;
      color: #ffd700;
      text-align: center;
    }

    .battle-status {
      font-size: 1.5rem;
      font-weight: bold;
      text-align: center;
      padding: 10px;
      border-radius: 8px;
    }

    .battle-status.ongoing { color: #4caf50; }
    .battle-status.victory { 
      color: #ffd700;
      background: rgba(76, 175, 80, 0.3);
    }
    .battle-status.defeat { 
      color: #ff6b6b;
      background: rgba(244, 67, 54, 0.3);
    }

    .control-buttons {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      width: 100%;
    }

    .control-buttons button {
      padding: 15px 24px;
      min-width: 120px;
      min-height: 50px;
      font-size: 1rem;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .control-buttons button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
    }

    .control-buttons button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .control-buttons button.primary {
      background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
    }

    .control-buttons button.danger {
      background: linear-gradient(135deg, #f44336 0%, #e57373 100%);
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
    }

    .speed-control label {
      font-weight: bold;
    }

    .speed-control select {
      flex: 1;
      padding: 8px;
      border-radius: 6px;
      border: none;
      background: rgba(255, 255, 255, 0.9);
      font-size: 1rem;
      cursor: pointer;
    }

    /* Skill Priority Editor Buttons */
    .move-btn {
      min-width: 40px;
      min-height: 40px;
      width: 40px;
      height: 40px;
      padding: 8px;
      font-size: 1.2rem;
      font-weight: bold;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .move-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
    }

    .move-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    /* Apply/Cancel Buttons */
    .action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      justify-content: flex-end;
    }

    .apply-btn,
    .cancel-btn {
      padding: 12px 32px;
      min-width: 100px;
      min-height: 44px;
      font-size: 1rem;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      color: #fff;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .apply-btn {
      background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
    }

    .cancel-btn {
      background: linear-gradient(135deg, #f44336 0%, #e57373 100%);
    }

    .apply-btn:hover:not(:disabled),
    .cancel-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
    }

    .apply-btn:disabled,
    .cancel-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Instructions Panel */
    .instructions-panel {
      flex: 1;
      overflow-y: auto;
      max-height: 600px;
    }

    .instructions-panel h2 {
      margin-bottom: 20px;
    }

    /* Action Forecast Panel */
    .forecast-panel {
      flex: 1;
      overflow-y: auto;
    }

    .forecast-panel h2 {
      margin-bottom: 20px;
    }

    .forecast-timeline {
      margin-bottom: 20px;
    }

    .forecast-timeline h3 {
      color: #64b5f6;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    .timeline-entry {
      padding: 8px 12px;
      margin-bottom: 6px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      border-left: 3px solid #2196f3;
    }

    .timeline-entry.queued {
      font-weight: bold;
      border-left-color: #ffd700;
      background: rgba(255, 215, 0, 0.1);
    }

    .timeline-entry .tick-number {
      color: #64b5f6;
      font-weight: bold;
      margin-right: 8px;
    }

    .character-forecast {
      margin-bottom: 20px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
    }

    .character-forecast h4 {
      color: #4caf50;
      margin-bottom: 8px;
    }

    .character-forecast.enemy h4 {
      color: #f44336;
    }

    .forecast-current-action,
    .forecast-next-action {
      margin: 8px 0;
      padding: 6px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .forecast-label {
      font-weight: bold;
      color: #64b5f6;
      margin-right: 5px;
    }

    .forecast-rules {
      margin-top: 10px;
    }

    .forecast-rules h5 {
      color: #9c27b0;
      font-size: 0.95rem;
      margin-bottom: 6px;
    }

    .rule-item {
      padding: 5px 8px;
      margin: 4px 0;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 4px;
      font-size: 0.85rem;
      font-family: monospace;
    }

    .rule-item.disabled {
      opacity: 0.5;
      text-decoration: line-through;
    }

    .rule-priority {
      display: inline-block;
      min-width: 24px;
      padding: 2px 6px;
      background: #9c27b0;
      border-radius: 3px;
      font-weight: bold;
      margin-right: 8px;
      font-size: 0.8rem;
    }

    /* Debug Inspector */
    .debug-inspector {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      padding: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .debug-inspector h3 {
      color: #ffd700;
      margin-bottom: 10px;
      font-size: 1.2rem;
      border-bottom: 2px solid rgba(255, 215, 0, 0.3);
      padding-bottom: 5px;
    }

    .rule-evaluations, .targeting-decisions, .resolution-substeps {
      margin-bottom: 20px;
    }

    .character-eval {
      background: rgba(255, 255, 255, 0.05);
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 10px;
    }

    .character-eval h4 {
      color: #64b5f6;
      margin-bottom: 8px;
    }

    .rule {
      padding: 5px 10px;
      margin: 5px 0;
      border-radius: 4px;
      font-family: monospace;
    }

    .rule.matched {
      background: rgba(76, 175, 80, 0.2);
      color: #a5d6a7;
    }

    .rule.failed {
      background: rgba(244, 67, 54, 0.2);
      color: #ef9a9a;
    }

    .conditions {
      font-size: 0.85rem;
      color: #b0bec5;
      margin-left: 20px;
      font-family: monospace;
    }

    .selected-action {
      color: #ffd700;
      font-weight: bold;
      margin-top: 8px;
    }

    .decision {
      background: rgba(255, 255, 255, 0.05);
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 0.9rem;
      font-family: monospace;
    }

    .substep {
      margin-bottom: 8px;
      padding: 5px;
      border-radius: 4px;
    }

    .substep.damage-calc { background: rgba(244, 67, 54, 0.2); }
    .substep.healing-calc { background: rgba(76, 175, 80, 0.2); }
    .substep.shield-absorption { background: rgba(33, 150, 243, 0.2); }
    .substep.health-update { background: rgba(255, 152, 0, 0.2); }
    .substep.status-application { background: rgba(156, 39, 176, 0.2); }
    .substep.action-cancel { background: rgba(255, 87, 34, 0.2); }

    /* Decision Flow Styles */
    .rule-step {
      border-left: 3px solid #666;
      padding: 8px 12px;
      margin: 8px 0;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    .rule-step.selected {
      border-left-color: #4ade80;
      background: rgba(74, 222, 128, 0.1);
    }

    .rule-step.skipped {
      border-left-color: #fbbf24;
      background: rgba(251, 191, 36, 0.1);
    }

    .rule-step.failed {
      border-left-color: #888;
    }

    .step-header {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .step-number {
      color: #888;
      font-weight: bold;
      min-width: 20px;
    }

    .status-badge {
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: bold;
    }

    .status-badge.selected {
      background: #4ade80;
      color: #000;
    }

    .status-badge.skipped {
      background: #fbbf24;
      color: #000;
    }

    .status-badge.failed {
      background: #666;
      color: #fff;
    }

    .step-details {
      font-size: 0.9rem;
      color: #ccc;
      margin-top: 4px;
      margin-left: 28px;
    }

    .not-reached-section {
      margin-top: 8px;
      font-size: 0.85rem;
      color: #888;
    }

    .not-reached-section summary {
      cursor: pointer;
      padding: 4px 0;
    }

    .not-reached-rule {
      padding: 2px 0 2px 20px;
    }

    .final-action {
      margin-top: 12px;
      padding: 8px 12px;
      background: rgba(59, 130, 246, 0.2);
      border-left: 3px solid #3b82f6;
      border-radius: 4px;
    }

    /* Event Log */
    .event-log {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      padding: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-height: 600px;
      overflow-y: auto;
    }

    .event-log h2 {
      color: #ffd700;
      margin-bottom: 10px;
      font-size: 1.3rem;
      text-align: center;
    }

    .event {
      display: flex;
      align-items: flex-start;
      flex-wrap: nowrap;
      gap: 8px;
      padding: 4px 8px;
      margin-bottom: 2px;
      border-radius: 4px;
      border-left: 3px solid;
      font-size: 0.85rem;
      line-height: 1.3;
    }

    .event.action-queued { 
      border-color: #2196f3;
      background: rgba(33, 150, 243, 0.1);
    }
    .event.action-resolved { 
      border-color: #9c27b0;
      background: rgba(156, 39, 176, 0.1);
    }
    .event.damage { 
      border-color: #f44336;
      background: rgba(244, 67, 54, 0.1);
    }
    .event.healing { 
      border-color: #4caf50;
      background: rgba(76, 175, 80, 0.1);
    }
    .event.status-applied { 
      border-color: #ff9800;
      background: rgba(255, 152, 0, 0.1);
    }
    .event.status-expired { 
      border-color: #607d8b;
      background: rgba(96, 125, 139, 0.1);
    }
    .event.knockout { 
      border-color: #d32f2f;
      background: rgba(211, 47, 47, 0.2);
      font-weight: bold;
    }
    .event.victory { 
      border-color: #ffd700;
      background: rgba(255, 215, 0, 0.2);
      font-weight: bold;
      font-size: 1.1rem;
    }
    .event.defeat { 
      border-color: #d32f2f;
      background: rgba(211, 47, 47, 0.2);
      font-weight: bold;
      font-size: 1.1rem;
    }

    .event .tick {
      font-weight: bold;
      color: #64b5f6;
      font-size: 0.8rem;
      min-width: 28px;
      flex-shrink: 0;
      white-space: nowrap;
      align-self: flex-start;
      padding-top: 1px;
    }

    .event .message {
      color: #fff;
      flex: 1;
      overflow-wrap: break-word;
      word-wrap: break-word;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      line-height: 1.3;
    }

    .event .separator {
      color: #ffd700;
      font-weight: bold;
      margin: 0 8px;
    }

    /* Skill Priority Editor */
    .skill-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .skill-item .skill-controls {
      display: flex;
      gap: 4px;
    }

    .skill-item .skill-name {
      flex: 1;
      font-weight: bold;
    }

    .skill-item .skill-priority {
      color: #ffd700;
      font-size: 0.9rem;
    }

    .skill-item.selected {
      background: rgba(255, 215, 0, 0.2);
      border: 1px solid #ffd700;
    }

    .skill-item.disabled .skill-name {
      opacity: 0.5;
      text-decoration: line-through;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    /* Character name color coding - now handled with inline styles for unique colors per character */
    /* Colors are assigned dynamically based on character ID for unique identification */

    /* Battle Arena Visualization */
    .battle-arena-panel {
      min-height: 550px;
    }

    #battle-arena-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .battle-arena-svg {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
    }

    /* Character circles */
    .character-circle .circle-border {
      fill: none;
      stroke-width: 3;
    }

    .character-circle .circle-border.player {
      stroke: #4caf50;
    }

    .character-circle .circle-border.enemy {
      stroke: #f44336;
    }

    .character-circle .circle-border.ko {
      stroke-dasharray: 5,3;
      stroke: #757575;
    }

    .character-circle .hp-fill.player {
      fill: url(#player-fill-gradient);
    }

    .character-circle .hp-fill.enemy {
      fill: url(#enemy-fill-gradient);
    }

    .character-circle .hp-fill.ko {
      fill: #424242;
    }

    .character-circle .hp-text {
      fill: white;
      font-weight: bold;
      font-size: 14px;
      text-anchor: middle;
      dominant-baseline: central;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }

    .character-circle .character-name {
      font-size: 12px;
      text-anchor: middle;
      font-weight: bold;
    }

    .character-circle .status-effects {
      fill: #b0bec5;
      font-size: 10px;
      text-anchor: middle;
    }

    .character-circle .action-display {
      fill: #ffd700;
      font-size: 11px;
      text-anchor: middle;
    }

    /* Intent lines */
    .intent-line {
      fill: none;
    }

    .intent-line.executing {
      stroke-width: 3;
    }

    .intent-line.queued {
      stroke-dasharray: 8,4;
      stroke-width: 2;
    }

    /* Selected character highlight */
    .character-circle.selected .circle-border {
      stroke: #ffd700 !important;
      stroke-width: 4;
      filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.6));
    }
    
    /* Tick Controls Panel (simplified) */
    .tick-controls-panel {
      padding: 15px 20px;
    }
    
    .tick-controls-panel .control-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
    }
    
    .tick-controls-panel .control-buttons button {
      flex: 1;
      max-width: 150px;
    }
    
    /* Bottom section full-width */
    .bottom-section {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-top: 20px;
    }
    
    /* Forecast panel fills right column */
    .forecast-panel {
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .forecast-panel #forecast-container {
      flex: 1;
      overflow-y: auto;
    }
    
    /* Skill Loadout UI (Prototype) */
    .loadout-panel {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .loadout-panel h2 {
      color: #ffd700;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .skill-pool {
      background: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    
    .skill-pool h3 {
      color: #64b5f6;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    
    .pool-skills {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 40px;
    }
    
    
    .character-loadouts {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
    }
    
    .character-loadout {
      background: rgba(255, 255, 255, 0.1);
      padding: 12px;
      border-radius: 8px;
      border: 2px solid #4caf50;
    }
    
    .character-loadout h4 {
      color: #4caf50;
      margin-bottom: 8px;
      font-size: 1rem;
    }
    
    .character-loadout .skill-count {
      font-size: 0.85rem;
      color: #b0bec5;
      margin-bottom: 8px;
    }
    
    .loadout-skills {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      min-height: 36px;
    }
    
    
    .empty-loadout {
      color: #888;
      font-style: italic;
      font-size: 0.85rem;
    }
    
    /* Skill Display with Tooltip */
    .skill-display {
      position: relative;
      cursor: help;
      display: inline-block;
      padding: 8px 16px;
      background: rgba(128, 128, 128, 0.3);
      border-radius: 6px;
      font-weight: bold;
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }
    
    /* Selectable variant (for pool/loadout) */
    .skill-display--selectable {
      cursor: pointer;
    }
    
    .skill-display--selectable:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    }
    
    /* Selected state */
    .skill-display--selected {
      border-color: #ffd700;
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.6);
    }
    
    /* Disabled state (innate skills) */
    .skill-display--disabled {
      opacity: 0.7;
      cursor: not-allowed;
    }
    
    .skill-tooltip {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      z-index: 10000;
      background: #1e1e1e;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 8px 12px;
      min-width: 180px;
      max-width: 250px;
      font-size: 0.85rem;
      line-height: 1.4;
      color: #e0e0e0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      
      /* Position below the skill display */
      left: 50%;
      top: calc(100% + 8px);
      transform: translateX(-50%);
      
      transition: opacity 0.15s ease-in-out, visibility 0.15s ease-in-out;
      pointer-events: none;
    }
    
    /* CSS-only hover activation */
    .skill-display:hover .skill-tooltip {
      visibility: visible;
      opacity: 1;
    }
    
    .skill-tooltip strong {
      color: inherit;
    }
    
    .skill-tooltip em {
      color: #888;
    }
    
    .skill-duration {
      color: #64b5f6;
      font-size: 0.85em;
      margin-left: 4px;
    }
  </style>
</head>
<body>
  <div class="battle-viewer">
    <h1>‚öîÔ∏è Battle Viewer ‚öîÔ∏è</h1>
    
    <!-- Three-column layout -->
    <div class="battle-arena">
      <!-- Left column: Battle Arena + Tick Controls -->
      <div class="battle-column-left">
        <!-- Battle Arena Panel -->
        <div class="panel battle-arena-panel">
          <h2>‚öîÔ∏è Battle Arena</h2>
          <div id="battle-arena-container"></div>
        </div>
        
        <!-- Tick Controls (directly below arena) -->
        <div class="panel tick-controls-panel">
          <div class="tick-display" id="tick-display">Tick: 0</div>
          <div class="battle-status ongoing" id="battle-status">Ongoing</div>
          
          <div class="control-buttons">
            <button id="step-back-btn">‚èÆÔ∏è Step Back</button>
            <button id="step-btn">Step Forward ‚è≠Ô∏è</button>
            <button id="reset-btn">üîÑ Reset</button>
          </div>
        </div>
      </div>
      
      <!-- Middle column: Rule Evaluations -->
      <div class="battle-column-middle">
        <!-- Rule Evaluations Panel (Debug Inspector) -->
        <div id="rule-evaluations-container"></div>
      </div>
      
      <!-- Right column: Rule Evaluations (Debug Inspector) OR Instructions Builder -->
      <div class="battle-column-right">
        <!-- Container that switches between Debug Inspector and Instructions Builder -->
        <div id="right-column-container"></div>
      </div>
    </div>
    
  </div>

  <script type="module">
    console.log('Battle Viewer script starting...');
    
    import { BattleController } from './dist/ui/battle-controller.js';
    import { renderCharacterCard } from './dist/ui/character-card.js';
    import { renderDebugInspector } from './dist/ui/debug-inspector.js';
    import { renderInstructionsBuilder } from './dist/ui/instructions-builder.js';
    import { renderControlModeToggle } from './dist/ui/control-mode-toggle.js';
    import { renderSkillPriorityEditor } from './dist/ui/skill-priority-editor.js';
    import { renderConditionBuilder } from './dist/ui/condition-builder.js';
    import { renderTargetingOverrideSelector } from './dist/ui/targeting-override-selector.js';
    import { renderActionForecast } from './dist/ui/action-forecast.js';
    import { analyzeVisualization } from './dist/ui/visualization-analyzer.js';
    import { renderBattleVisualization } from './dist/ui/battle-visualization.js';
    import { renderSkillDisplay } from './dist/ui/skill-display.js';
    import { ViewModelFactory } from './dist/ui/view-model-factory.js';
    import { TickExecutor } from './dist/engine/tick-executor.js';
    import { SkillLibrary } from './dist/engine/skill-library.js';
    import { debugDistributeSkill, debugUnequipSkill, debugAddCharacter, debugRemoveCharacter } from './dist/run/debug-character-manager.js';

    console.log('Imports loaded successfully');

    // Get DOM elements
    const battleArenaContainer = document.getElementById('battle-arena-container');
    const rightColumnContainer = document.getElementById('right-column-container');
    const ruleEvaluationsContainer = document.getElementById('rule-evaluations-container');
    const tickDisplay = document.getElementById('tick-display');
    const battleStatus = document.getElementById('battle-status');
    
    const stepBtn = document.getElementById('step-btn');
    const stepBackBtn = document.getElementById('step-back-btn');
    const resetBtn = document.getElementById('reset-btn');

    // Load skills from library
    const strike = SkillLibrary.getSkill('strike');
    const defend = SkillLibrary.getSkill('defend');
    const heal = SkillLibrary.getSkill('heal');
    const shield = SkillLibrary.getSkill('shield');
    const poison = SkillLibrary.getSkill('poison');

    // Create sample encounter (1v1 with standardized names)
    const sampleEncounter = {
      players: [
        {
          id: 'player-1',
          name: 'Player 1',
          maxHp: 100,
          currentHp: 100,
          skills: [strike, defend],
          statusEffects: [],
          currentAction: null,
          isPlayer: true,
        },
      ],
      enemies: [
        {
          id: 'enemy-1',
          name: 'Enemy 1',
          maxHp: 80,
          currentHp: 80,
          skills: [strike, defend],
          statusEffects: [],
          currentAction: null,
          isPlayer: false,
        },
      ],
      tickNumber: 0,
      actionQueue: [],
      eventLog: [],
      battleStatus: 'ongoing',
    };

    // Initialize DebugBattleState for character/skill management
    let debugState = {
      characters: [...sampleEncounter.players, ...sampleEncounter.enemies],
      skillPool: SkillLibrary.getAllSkills()
        .filter(s => s.id !== 'strike' && s.id !== 'defend')
        .map(s => s.id)
    };
    
    let selectedSkillId = null; // Track selected skill from pool
    
    // Initialize battle controller (will update when skills are distributed)
    let battleController = new BattleController(sampleEncounter);
    let lastDebugInfo = null;
    
    // Skill color mapping
    function getSkillColor(skillId) {
      // Explicit color overrides for important skills
      const explicitColors = {
        strike: '#e74c3c',      // Red
        defend: '#607d8b',      // Grey-blue
        heal: '#2ecc71',        // Green
        shield: '#3498db',      // Blue
        poison: '#9b59b6',      // Purple
      };
      
      if (explicitColors[skillId]) {
        return explicitColors[skillId];
      }
      
      // Generate unique color from skill ID hash
      let hash = 0;
      for (let i = 0; i < skillId.length; i++) {
        hash = skillId.charCodeAt(i) + ((hash << 5) - hash);
      }
      
      // Convert to HSL for good distribution (avoid too dark/light)
      const hue = Math.abs(hash) % 360;
      const saturation = 65 + (Math.abs(hash >> 8) % 20); // 65-85%
      const lightness = 55 + (Math.abs(hash >> 16) % 15);  // 55-70%
      
      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }
    
    // Select skill from pool
    window.selectSkillFromPool = function(skillId) {
      if (selectedSkillId === skillId) {
        selectedSkillId = null; // Deselect
      } else {
        selectedSkillId = skillId;
      }
      renderBattle();
    };
    
    // Assign skill to ANY character (player or enemy) in debug mode
    window.assignSkillToCharacter = function(characterId, skillId) {
      if (!skillId) return;
      
      try {
        debugState = debugDistributeSkill(debugState, skillId, characterId);
        selectedSkillId = null;
        updateBattleWithLoadout();
      } catch (error) {
        console.error('Failed to distribute skill:', error.message);
      }
    };
    
    // Unequip skill from ANY character back to pool
    window.unequipSkillFromCharacter = function(characterId, skillId) {
      try {
        debugState = debugUnequipSkill(debugState, skillId, characterId);
        updateBattleWithLoadout();
      } catch (error) {
        console.error('Failed to unequip skill:', error.message);
      }
    };
    
    // Add new character to debug battle
    window.addCharacter = function(isPlayer) {
      // Count existing characters of this type
      const existingOfType = debugState.characters.filter(c => c.isPlayer === isPlayer);
      const characterNumber = existingOfType.length + 1;
      
      const newId = isPlayer ? `player-${characterNumber}` : `enemy-${characterNumber}`;
      const newCharacter = {
        id: newId,
        name: isPlayer ? `Player ${characterNumber}` : `Enemy ${characterNumber}`,
        maxHp: 100,
        currentHp: 100,
        skills: [SkillLibrary.getSkill('strike'), SkillLibrary.getSkill('defend')],
        statusEffects: [],
        currentAction: null,
        isPlayer: isPlayer
      };
      
      try {
        debugState = debugAddCharacter(debugState, newCharacter);
        updateBattleWithLoadout();
      } catch (error) {
        console.error('Failed to add character:', error.message);
      }
    };
    
    // Remove character from debug battle
    window.removeCharacter = function(characterId) {
      try {
        debugState = debugRemoveCharacter(debugState, characterId);
        // Clear selection if removed character was selected
        const instructionsState = battleController.getInstructionsState();
        if (instructionsState.selectedCharacterId === characterId) {
          battleController.selectCharacter(null);
        }
        updateBattleWithLoadout();
      } catch (error) {
        console.error('Failed to remove character:', error.message);
      }
    };
    
    // Update battle controller with current debug state
    function updateBattleWithLoadout() {
      // Preserve selected character across controller recreation
      const previousSelectedCharacterId = battleController.getInstructionsState().selectedCharacterId;
      
      // Separate characters by isPlayer flag
      const players = debugState.characters.filter(c => c.isPlayer).map(char => ({
        ...char,
        currentHp: char.maxHp, // Reset HP
        statusEffects: [],
        currentAction: null,
      }));
      
      const enemies = debugState.characters.filter(c => !c.isPlayer).map(char => ({
        ...char,
        currentHp: char.maxHp, // Reset HP
        statusEffects: [],
        currentAction: null,
      }));
      
      const updatedEncounter = {
        players,
        enemies,
        tickNumber: 0,
        actionQueue: [],
        eventLog: [],
        battleStatus: 'ongoing',
      };
      
      battleController = new BattleController(updatedEncounter);
      
      // Restore selected character
      if (previousSelectedCharacterId) {
        battleController.selectCharacter(previousSelectedCharacterId);
      }
      
      refreshDebugInfo();
      renderBattle();
    }

    // Refresh debug info with current instructions (for when instructions change)
    function refreshDebugInfo() {
      const state = battleController.getCurrentState();
      const tickResult = TickExecutor.executeTickWithDebug(state, battleController.getInstructionsState().instructions);
      lastDebugInfo = tickResult.debugInfo;
    }

    // Helper to refresh debug info AND render (call when instructions change)
    function refreshDebugInfoAndRender() {
      refreshDebugInfo();
      renderBattle();
    }

    // Render functions
    function renderBattle() {
      const state = battleController.getCurrentState();
      const instructionsState = battleController.getInstructionsState();
      const selectedCharacterId = instructionsState.selectedCharacterId;
      
      // Get forecast for predicted intent lines
      const forecast = battleController.getForecast();
      
      // Render battle arena (new circle visualization) with forecast for predicted lines
      const visualization = analyzeVisualization(state, forecast);
      battleArenaContainer.innerHTML = renderBattleVisualization(visualization);
      
      // After rendering, mark selected character
      if (selectedCharacterId) {
        const selectedCircle = document.querySelector(`.character-circle[data-character-id="${selectedCharacterId}"]`);
        if (selectedCircle) {
          selectedCircle.classList.add('selected');
        }
      }
      
      // Render middle column: Rule Evaluations (Debug Inspector)
      if (lastDebugInfo) {
        ruleEvaluationsContainer.innerHTML = renderDebugInspector(lastDebugInfo);
      } else {
        ruleEvaluationsContainer.innerHTML = '';
      }
      
      // Render right column: Available Skills + Character Inventory + Instructions (if character selected)
      if (selectedCharacterId) {
        // Render skill pool, character inventory and instructions in right column
        const selectedCharacter = battleController.getSelectedCharacter();
        const selectedInstructions = battleController.getSelectedCharacterInstructions();
        
        // Get character from debugState to show equipped skills (works for both players AND enemies)
        const debugCharacter = debugState.characters.find(c => c.id === selectedCharacterId);
        
        const characterType = selectedCharacter.isPlayer ? 'Player' : 'Enemy';
        const headerColor = selectedCharacter.isPlayer ? '#4caf50' : '#f44336';
        
        rightColumnContainer.innerHTML = `
          <div class="panel" style="margin-bottom: 15px; padding: 15px; position: relative; z-index: 1000;">
            <h3 style="color: #64b5f6; margin-bottom: 10px; font-size: 1rem;">Available Skills</h3>
            <div style="display: flex; flex-wrap: wrap; gap: 6px; min-height: 36px;">
              ${debugState.skillPool.length === 0
                ? '<div class="empty-loadout">All skills assigned!</div>'
                : debugState.skillPool.map(skillId => {
                    const skill = SkillLibrary.getSkill(skillId);
                    const skillVM = ViewModelFactory.createSkillViewModel(skill);
                    return `<div onclick="selectSkillFromPool('${skillId}')">${renderSkillDisplay(skillVM, {
                      showDuration: false,
                      selectable: true,
                      selected: selectedSkillId === skillId
                    })}</div>`;
                  }).join('')
              }
            </div>
          </div>
          
          <div class="panel" style="margin-bottom: 15px; padding: 15px; position: relative; z-index: 1000; cursor: ${selectedSkillId ? 'pointer' : 'default'};"
               ${selectedSkillId ? `onclick="assignSkillToCharacter('${selectedCharacterId}', '${selectedSkillId}')"` : ''}>
            <h3 style="color: ${headerColor}; margin-bottom: 10px; font-size: 1rem;">
              üéí ${selectedCharacter.name}'s Equipped Skills
              <span style="color: #b0bec5; font-size: 0.85rem;">(${debugCharacter ? debugCharacter.skills.filter(s => s.id !== 'strike' && s.id !== 'defend').length : 0}/4)</span>
            </h3>
            <div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.2);">
              <div style="font-size: 0.85rem; color: #888; margin-bottom: 4px;">Innate:</div>
              <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                ${renderSkillDisplay(ViewModelFactory.createSkillViewModel(SkillLibrary.getSkill('strike')), {
                  showDuration: false,
                  disabled: true
                })}
                ${renderSkillDisplay(ViewModelFactory.createSkillViewModel(SkillLibrary.getSkill('defend')), {
                  showDuration: false,
                  disabled: true
                })}
              </div>
            </div>
            <div style="display: flex; flex-wrap: wrap; gap: 6px; min-height: 36px;">
              ${debugCharacter && debugCharacter.skills.filter(s => s.id !== 'strike' && s.id !== 'defend').length > 0
                ? debugCharacter.skills.filter(s => s.id !== 'strike' && s.id !== 'defend').map(skill => {
                    const skillVM = ViewModelFactory.createSkillViewModel(skill);
                    return `<div onclick="event.stopPropagation(); unequipSkillFromCharacter('${selectedCharacterId}', '${skill.id}')">${renderSkillDisplay(skillVM, {
                      showDuration: false
                    })}</div>`;
                  }).join('')
                : `<div class="empty-loadout">${selectedSkillId ? 'Click here to assign selected skill' : 'Select a skill above to equip'}</div>`
              }
            </div>
            
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.2);">
              <button onclick="removeCharacter('${selectedCharacterId}')"
                      style="width: 100%; padding: 10px; background: linear-gradient(135deg, #f44336 0%, #e57373 100%); color: white; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.3s ease;">
                üóëÔ∏è Remove ${characterType}
              </button>
            </div>
          </div>
          
          <div class="panel instructions-panel">
            <h2 style="font-size: 1.2rem;">üéÆ Instructions</h2>
            ${renderInstructionsBuilder(
              debugCharacter || selectedCharacter,
              selectedInstructions,
              battleController.getEditingSkillId(),
              instructionsState.isDirty
            )}
          </div>
        `;
      } else {
        // Show character management controls when no character selected
        rightColumnContainer.innerHTML = `
          <div class="panel" style="padding: 20px;">
            <h3 style="color: #ffd700; margin-bottom: 15px; text-align: center;">üéÆ Debug Battle Builder</h3>
            <p style="text-align: center; color: #b0bec5; margin-bottom: 20px; font-size: 0.9rem;">
              Add characters and assign skills to create custom battles
            </p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
              <button onclick="addCharacter(true)"
                      style="padding: 15px; background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 1rem; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
                ‚ûï Add Player
              </button>
              <button onclick="addCharacter(false)"
                      style="padding: 15px; background: linear-gradient(135deg, #f44336 0%, #e57373 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 1rem; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
                ‚ûï Add Enemy
              </button>
            </div>
            <p style="text-align: center; color: #888; margin-top: 20px; font-size: 0.85rem; font-style: italic;">
              Click a character in the arena to manage their skills and AI instructions
            </p>
          </div>
        `;
      }
      
      // Render tick display
      tickDisplay.textContent = `Tick: ${state.tickNumber}`;
      
      // Render battle status
      battleStatus.textContent = state.battleStatus.charAt(0).toUpperCase() + state.battleStatus.slice(1);
      battleStatus.className = `battle-status ${state.battleStatus}`;
      
      // Update button states
      updateButtonStates();
    }

    function updateButtonStates() {
      const state = battleController.getCurrentState();
      const battleEnded = state.battleStatus !== 'ongoing';
      
      stepBtn.disabled = battleEnded;
      stepBackBtn.disabled = state.tickNumber === 0;
      resetBtn.disabled = false;
    }

    // Character selection handler (for arena circles - shows Instructions in right column)
    document.addEventListener('click', (e) => {
      const circle = e.target.closest('.character-circle');
      
      if (circle) {
        const characterId = circle.dataset.characterId;
        if (characterId) {
          const instructionsState = battleController.getInstructionsState();
          // Toggle selection: if clicking the same character, deselect
          if (instructionsState.selectedCharacterId === characterId) {
            battleController.selectCharacter(null);
          } else {
            battleController.selectCharacter(characterId);
          }
          // BUG FIX 1: Clear skill selection when switching characters
          selectedSkillId = null;
          renderBattle();
        }
      }
    });

    // Instructions panel event handlers
    document.addEventListener('click', (e) => {
      const target = e.target;
      const action = target.dataset.action;
      
      if (!action) return;
      
      const instructionsState = battleController.getInstructionsState();
      const characterId = instructionsState.selectedCharacterId;
      
      if (!characterId && action !== 'cancel') return;
      
      switch (action) {
        case 'set-human':
          battleController.updateControlMode(characterId, 'human');
          refreshDebugInfoAndRender();
          break;
          
        case 'set-ai':
          battleController.updateControlMode(characterId, 'ai');
          refreshDebugInfoAndRender();
          break;
          
        case 'move-up': {
          const skillId = target.closest('[data-skill-id]')?.dataset.skillId;
          if (skillId) {
            const instructions = battleController.getSelectedCharacterInstructions();
            const currentIndex = instructions.skillInstructions.findIndex(si => si.skillId === skillId);
            if (currentIndex > 0) {
              battleController.updateSkillPriority(characterId, skillId, currentIndex - 1);
              refreshDebugInfoAndRender();
            }
          }
          break;
        }
          
        case 'move-down': {
          const skillId = target.closest('[data-skill-id]')?.dataset.skillId;
          if (skillId) {
            const instructions = battleController.getSelectedCharacterInstructions();
            const currentIndex = instructions.skillInstructions.findIndex(si => si.skillId === skillId);
            if (currentIndex < instructions.skillInstructions.length - 1) {
              battleController.updateSkillPriority(characterId, skillId, currentIndex + 1);
              refreshDebugInfoAndRender();
            }
          }
          break;
        }
          
        case 'toggle-skill': {
          const skillId = target.dataset.skillId;
          if (skillId) {
            battleController.toggleSkillEnabled(characterId, skillId);
            refreshDebugInfoAndRender();
          }
          break;
        }
          
        case 'add-condition': {
          const skillId = battleController.getEditingSkillId();
          if (skillId) {
            // Create a default condition
            const condition = {
              type: 'hp-below',
              value: 50
            };
            battleController.addCondition(characterId, skillId, condition);
            refreshDebugInfoAndRender();
          }
          break;
        }
          
        case 'remove-condition': {
          const skillId = battleController.getEditingSkillId();
          const conditionIndex = parseInt(target.dataset.conditionIndex, 10);
          if (skillId && !isNaN(conditionIndex)) {
            battleController.removeCondition(characterId, skillId, conditionIndex);
            refreshDebugInfoAndRender();
          }
          break;
        }
          
        case 'apply':
          battleController.applyInstructions();
          refreshDebugInfoAndRender();
          break;
          
        case 'cancel':
          battleController.discardChanges();
          battleController.selectCharacter(null);
          renderBattle();
          break;
      }
    });

    // Skill selection handler
    document.addEventListener('click', (e) => {
      const skillItem = e.target.closest('.skill-item');
      if (skillItem && !e.target.closest('button')) {
        const skillId = skillItem.dataset.skillId;
        if (skillId) {
          const currentEditingSkillId = battleController.getEditingSkillId();
          // Toggle: if clicking the same skill, deselect
          battleController.setEditingSkill(skillId === currentEditingSkillId ? null : skillId);
          renderBattle();
        }
      }
    });

    // Targeting override change handler
    document.addEventListener('change', (e) => {
      const target = e.target;
      if (target.dataset.input === 'targeting-override') {
        const instructionsState = battleController.getInstructionsState();
        const characterId = instructionsState.selectedCharacterId;
        const skillId = battleController.getEditingSkillId();
        
        if (characterId && skillId) {
          const value = target.value || undefined;
          battleController.updateTargetingOverride(characterId, skillId, value);
          refreshDebugInfoAndRender();
        }
      }
    });

    // Control button handlers
    stepBtn.addEventListener('click', () => {
      const state = battleController.getCurrentState();
      if (state.battleStatus === 'ongoing') {
        // Execute the actual tick
        const tickResult = TickExecutor.executeTickWithDebug(state, battleController.getInstructionsState().instructions);
        lastDebugInfo = tickResult.debugInfo;
        battleController.step();
        
        // After step, refresh debug info to show NEXT intents for idle characters
        const newState = battleController.getCurrentState();
        if (newState.battleStatus === 'ongoing') {
          const previewResult = TickExecutor.executeTickWithDebug(newState, battleController.getInstructionsState().instructions);
          lastDebugInfo = previewResult.debugInfo;
        }
      }
      renderBattle();
    });

    stepBackBtn.addEventListener('click', () => {
      battleController.stepBack();
      // Get debug info for the state we stepped back to
      const state = battleController.getCurrentState();
      const tickResult = TickExecutor.executeTickWithDebug(state, battleController.getInstructionsState().instructions);
      lastDebugInfo = tickResult.debugInfo;
      renderBattle();
    });

    resetBtn.addEventListener('click', () => {
      // Reset debug state to initial 1v1 configuration (Player 1 vs Enemy 1)
      debugState = {
        characters: [...sampleEncounter.players, ...sampleEncounter.enemies],
        skillPool: SkillLibrary.getAllSkills()
          .map(s => s.id)
          .filter(id => id !== 'strike' && id !== 'defend')
      };
      selectedSkillId = null;
      updateBattleWithLoadout();
    });

    // Initial sync: update battle controller with runState skills
    updateBattleWithLoadout();
  </script>
</body>
</html>
